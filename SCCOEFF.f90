! -------------------------------------------------------------------------
!
SUBROUTINE SCCOEFF(ROI,TI,PCI,FREQ,WIFR,GAI,SCCHO,GBIH,GBIV,GS6,&
GA2I,NUM,EPSI,EPSII)
!
! -------------------------------------------------------------------------
!
! CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MOD. BY MIKE (SEE HISTORY)
!
!   CALCULATES THE SCATTERING COEFFICIENT FROM STRUCTURAL PARAMETERS
!     DIFFERENT ALGORITHMS CAN BE CHOSEN, BY CHANGING "SCCHO"
!
!   [GBIH,GBIV,GS6,GA2I] = SCCOEFF(ROI,TI,PCI,FREQ,WI,GAI,SCCHO)
!       GBIH:  2-FLUX SCATTERING COEFFICIENT AT H POL
!       GBIV:  2-FLUX SCATTERING COEFFICIENT AT V POL
!       GS6:   6-FLUX SCATTERING COEFFICIENT
!       GA2I:  2-FLUX ABSORPTION COEFFICIENT
!       ROI:   DENSITY
!       TI:    PHYSICAL TEMPERATURE
!       PCI:   CORRELATION LENGTH
!       FREQ:  FREQUENCY
!       WI:    WETNESS
!       GAI:   ABSORPTION COEFFICIENT
!       SCCHO: SCATTERING COEFFICIENT ALGORITHM CHOSEN
!
!   VERSION HISTORY:
!      1.0B    WI 15.7.95
!      1.0     WI 23.9.97 BUG FIXED
!      1.1     WI 26.9.97 LATEST FIT ON EXPERIMENTAL DATA WAS ADDED (OPTION 7)
!      1.2     WI 13.10.97 OPTION 8 ADDED, ADAPTED SCATTERING OF A SHELL/SPHERE
!                            TO NOTE 9/VER2
!      1.3     WI  4.11.97 OPTION 9, 10 AND 11 ADDED
!      1.4     WI 27.05.98 BORN APPROXIMATION ADDED (BORNA.M)
!      2.0     MD 1 APR 05 CALL TO BORNA CHANGED TO CALL TO BORN (BY MIKE).
!                            ALL OPTIONS FOR OTHER SHAPES REMOVED BUT BORN
!                            APPROX AND THE APPROX FOR FINE GRAIN SNOW IN
!                            WIESMANN AND MATZLER 1999
!      2.0     MD 21 NOV 05  MADE ALL LOCALS DYNAMICALLY ALLOCATABLE
!
!   USES: BORN
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM,SCCHO
REAL, INTENT(IN) :: ROI(NUM),TI(NUM),PCI(NUM),FREQ,WIFR(NUM),&
GAI(NUM),EPSI(NUM),EPSII(NUM)
REAL, INTENT(OUT) :: GBIH(NUM),GBIV(NUM),GS6(NUM),GA2I(NUM)
REAL C,ROAIR,ROICE,DGB0H,DGB0V,K,EICE,PI
REAL,DIMENSION(:),ALLOCATABLE ::  VFI,KP,GB6,GC6,GF6,GTR,OMEGA
INTEGER :: I,IERR !IERR USED FOR MPI_FINALIZE IF WE HAVE AN ERROR

!integer, intent(in) :: pixel,replicate,rank,meas

ALLOCATE( VFI(NUM),KP(NUM),GB6(NUM),GC6(NUM),GF6(NUM),GTR(NUM),OMEGA(NUM) )

! CONSTANTS
PI=3.14159
C=2.99
ROAIR=0.001293
ROICE=0.917

! SPECULAR COMPONENT OF SCATTERING COEFFICIENT
!   USUALLY 0 CAN BE IMPORTANT IN NEW SNOW!
DGB0H=0.0
DGB0V=0.0
K=FREQ*2.*PI/0.299793
EICE=3.18
VFI=ROI/ROICE

IF (SCCHO==1) THEN
!DUE TO A BAD UDPATE, I'M ADDING A CHECK TO VERIFY THAT ROI IS REASONABLE
!THE CONSTANTS IN THE FOLLOWING LINE ARE DERIVED FROM EMPIRICAL RELATIONSHIP
!IN THE CALCULATION OF GS6
!Jinmei, removed this line for empirical memls mcmc runs
!DO I=1,NUM
!IF(ROI(I).GE.(7.48*PCI(I)+0.439))THEN
!PRINT *, 'ERROR IN SCCOEFF: DENSITY IS TOO LARGE OR GRAIN SIZE IS', &
!'TOO SMALL; ROI(I)=',ROI(I),'PCI(I)=',PCI(I),'LAYER#=',I,&
!'. STOPPING PROGRAM EXECUTION'
!!      CALL MPI_FINALIZE(IERR)
!STOP
!END IF
!END DO
!FIT VOM 4.11.97 (WITH DENSITY, USES CORR. LENGTH FROM EXP. FIT!)
GS6=(9.2*PCI-1.23*ROI+0.54)**2.5*(FREQ/50.)**2.5
OMEGA=((EPSI-1)/EPSI)**0.5
GB6=0.5*GS6*(1-OMEGA)
GC6=0.25*GS6*OMEGA
ELSEIF (SCCHO==2) THEN
! BORN APPROXIMATION
CALL BORN(K,VFI,PCI,EPSI,EICE,GB6,GC6,GF6,GS6,NUM)
END IF

! COMPUTE OTHER SCATTERING COEFFICIENTS

GTR=(4*GC6)/(GAI+2*GC6)
GA2I=GAI*(1+GTR)
GBIH=(GB6+DGB0H)+GTR*GC6
GBIV=(GB6+DGB0V)+GTR*GC6

DEALLOCATE( VFI,KP,GB6,GC6,GF6,GTR,OMEGA )

END SUBROUTINE SCCOEFF





! -------------------------------------------------------------------------
!
SUBROUTINE POLDER(VFI,A,EICE,EPSI,EPSEFF,NUM)
!
! -------------------------------------------------------------------------
!  WRITTEN BY MIKE, 1 APRIL 05
!  SOLVES (1) THROUGH (5) IN MATZLER, 1996 IN IEEE
!  IMPLEMENTS NEWTON-RAPHSON ITERATION TECHNIQUE IN ORDER TO SOLVE THE RESULT
!  OF SUBSTITUTING EQUATIONS (4) AND (5) INTO (3),THEN (3) INTO (1) AND SOLVING.
!  FOR DOCUMENTATION, SEE REPORT "SOLVING FOR EEFF.SXW" UNDER REPORTS/MEMLS
!  FOLDER.
!
!  INPUTS: V - VOLUME FRACTION OF ICE
!          A - DEPOLARIZATION FACTOR
!          EICE - ICE PERMITTIVITY
!          EPSI - DRY SNOW PERMITTIVITY
!  OUTPUT: EPSEFF - EFFECITVE ICE PERMITTIVITY

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: VFI(NUM),A(NUM),EICE,EPSI(NUM)
REAL, INTENT(OUT) :: EPSEFF(NUM)
REAL EPS,X,F,U1,V1,U2,V2,B,T,DBDX,DTDX,DFDX,DELTAX
INTEGER I,K

EPS=0.001
DO I=1,NUM
    !X=1-EPSI(I)    !X0, INITIAL GUESS
    X=EPSI(I)-1    !Revised Jinmei!
    F=EPS*10       !DUMMY VALUE FOR FIRST GUESS
    K=1            !ITERATION COUNTER
    DO
        K=K+1

        U1=2*(1+(1-A(I))*X)
        V1=1+(1-A(I))*X+A(I)*(EICE-1)
        U2=1+2*A(I)*X
        V2=1+2*A(I)*X+(1-2*A(I))*(EICE-1)

        B=3-VFI(I)*(EICE-1)*(2*A(I)/V1+(1-2*A(I))/V2) !Demoninator of eps_eff-eps_1 in eq(22), where eps_1=1

        T=VFI(I)*(EICE-1)*(U1/V1+U2/V2)               !Numerator of eps_eff-eps_1 in eq(22)

        DBDX=2*A(I)*VFI(I)*(EICE-1)*((1-A(I))/V1**2+(1-2*A(I))/V2**2)
        DTDX=DBDX*(EICE-1)
        !DFDX=1-(B*DTDX-T*DBDX)/B**2   !Jinmei revised, I think it needs to be revised accordingly
        DFDX=(B*DTDX-T*DBDX)/B**2

        DELTAX=-1*F/DFDX
        X=X+DELTAX

        F=X-T/B
        IF (ABS(F)<EPS) EXIT    ! TEST WHETHER WE ARE CLOSE ENOUGH TO ZERO
    END DO
        EPSEFF(I)=X+1
END DO

END SUBROUTINE POLDER





! -------------------------------------------------------------------------
!
SUBROUTINE BORN(K,VFI,PCIMM,EPSI,EICE,GB6,GC6,GF6,GS6,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER, MODIFIED BY MIKE... SEE
!     VERSION HISTORY
!
!   CALCULATES THE SCATTERING COEFFICIENT USING BORN APPROXIMATION
!
!   [GB6,GC6,GF6,GS6] = BORNA(K,VFI,PCI,EPSI,EICE,EPSEFF,KP)
!       GB6: 6-FLUX BACK SCATTERING COEFFICIENT
!       GC6: 6-FLUX CROSS SCATTERING COEFFICIENT
!       GF6: 6-FLUX FORWARD SCATTERING COEFFICIENT
!       GS6: 6-FLUX SCATTERING COEFFICIENT
!       K:   WAVE NUMBER
!       VFI: VOLUME FRACTION OF ICE
!       PCI: CORRELATION LENGTH
!       EPSI: DIELECTRIC CONSTANT OF SNOW
!       EICE: DIELECTRIC CONSTANT OF SNOW
!       EPSEFF: EFFECTIVE PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98
!      2.0     WI 31.03.05.  TRANSLATED TO FORTRAN BY MIKE.  BORNA AND
!                             BORNSNK COMBINED INTO ONE.  CALL TO POLDER
!                             IS USED TO COMPUTE EFFECTIVE PERMITTIVITY
!      3.0    MD  1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      3.1    MD 22 DEC 11 Added Unity,NegUnity variables to prevent compiler warnings
!
!   USES:
!
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: K,VFI(NUM),PCIMM(NUM),EPSI(NUM),EICE
REAL, INTENT(OUT) :: GB6(NUM),GC6(NUM),GF6(NUM),GS6(NUM)
REAL,DIMENSION(:),ALLOCATABLE :: PCI,A,A3,EA,EA3,K1,K3,KP,MUC,AA,XX,BB,BT,BF,&
BTOT, EPSEFF,NEGMUC
Real,Parameter,Dimension(1) :: Unity=1.,NegUnity=-1.
INTEGER STEPS,ROW,ARG_LENGTH(2),I

!integer,intent(in) :: pixel,replicate,rank,meas

ALLOCATE( PCI(NUM),A(NUM),A3(NUM),EA(NUM),EA3(NUM),K1(NUM),K3(NUM),KP(NUM),&
MUC(NUM),AA(NUM),XX(NUM),BB(NUM),BT(NUM),BF(NUM),BTOT(NUM),&
EPSEFF(NUM),NEGMUC(NUM) )

! 0)  CONSTANTS AND CONVERSION
STEPS=11
PCI=PCIMM*0.001

! 1)  COMPUTE FIELD FACTOR AND DEPOLARIZATION RATIO, FROM BORNSNK
!     'A' AFTER NOTE 10, MATZLER 1997, COMMENT AND CALL FROM BORNSNK
CALL SNOWAO(VFI,A,NUM)

! 2)  COMPUTE EFFECTIVE PERMITTIVITY USING NEW FUNCTION POLDER.M

!CALL POLDER(VFI,A,EICE,EPSI,EPSEFF,NUM)  !Jinmei commented on Dec22,2015, because MEMLS3 code does not contain this
EPSEFF=EPSI

! 3)  COMPUTE KP, THE SQUARED RATIO BETWEEN INTERNAL / EXTERNAL FIELDS
!     THIS CODE ORIGINALLY IN BORNSNK, STARTING AT LINE 41
A3=1-2*A
EA=EPSEFF*(1-A)+A
EA3=EPSEFF*(1-A3)+A3
K1=(EA/(EA+A*(EICE-1)))**2
K3=(EA3/(EA3+A3*(EICE-1)))**2
KP=(2*K1+K3)/3

! 4)  COMPUTE SCATTERING COEFFICIENTS, FROM BORNA, STARTING AT LINE 34

!NOTE: THE NEXT LINE CONSISTENT WITH MATZLER AND WIESMANN 99 PAPER EQUATION (7).
!  BASED ON CORRESPONDENCE WITH MATZLER, EPSEFF=N^2

MUC=((EPSEFF-1)/EPSEFF)**0.5

AA=2*(PCI*K)**3*K*VFI*(1-VFI)*(EICE-1)**2*KP
XX=PCI*K*EPSI**0.5

! 5)  TRIPLE INTEGRATION

!  A) BACKWARD SCATTERING
ARG_LENGTH=(/1, NUM/)
NEGMUC=-1.*MUC
!!!CALL INTEGRMUI(XX,MUC,1.,-1.,-1.*MUC,STEPS,NUM,BB,ARG_LENGTH)
!CALL INTEGRMUI(XX,MUC,1.,-1.,NEGMUC,STEPS,NUM,BB,ARG_LENGTH) !Orig: 22 Dec
CALL INTEGRMUI(XX,MUC,1.,NegUnity,NEGMUC,STEPS,NUM,BB,ARG_LENGTH) !MDrev
!  B) TRANSVERSE SCATTERING
ARG_LENGTH=(/NUM, NUM/)
!CALL INTEGRMUI(XX,MUC,1.,-1.*MUC,MUC,STEPS,NUM,BT,ARG_LENGTH)
CALL INTEGRMUI(XX,MUC,1.,NEGMUC,MUC,STEPS,NUM,BT,ARG_LENGTH)
!  C) FORWARD SCATTERING
ARG_LENGTH=(/NUM, 1/)
!CALL INTEGRMUI(XX,MUC,1.,MUC,1.,STEPS,NUM,BF,ARG_LENGTH) !Orig: 22 Dec 11
CALL INTEGRMUI(XX,MUC,1.,MUC,Unity,STEPS,NUM,BF,ARG_LENGTH)

! 6)  CALCULATION OF SCATTERING COEFFICIENTS

BTOT=BB+BT+BF
GB6=AA*BB
GC6=0.25*AA*BT
GF6=AA*BF
GS6=AA*BTOT

DEALLOCATE( PCI,A,A3,EA,EA3,K1,K3,KP,MUC,AA,XX,BB,BT,BF,BTOT, EPSEFF,NEGMUC)

END SUBROUTINE BORN





! -------------------------------------------------------------------------
!
SUBROUTINE INTEGRMUI(XX,MINI,MAXI,MINO,MAXO,STEPS,NUM,INTEGR,ARG_LENGTH)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINI TO MAXI IN STEPS INTERVALS OF THE FI AND
!       MUO INTEGRATED PHASE FUNCTION.
!
!
!   INTEGR = INTEGRMUI(XX,MINI,MAXI,MINO,MAXO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: INTEGRMUO
!
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM,STEPS,ARG_LENGTH(2)
REAL, INTENT(IN) :: XX(NUM),MINI(NUM),MAXI,MINO(ARG_LENGTH(1)),&
MAXO(ARG_LENGTH(2))
REAL, INTENT(OUT) :: INTEGR(NUM)
REAL :: STEPSR
REAL,DIMENSION(:),ALLOCATABLE :: DMU,DELTA,F0,MUI,FUNC
INTEGER IMU

ALLOCATE( DMU(NUM),DELTA(NUM),F0(NUM),MUI(NUM),FUNC(NUM) )

STEPSR=REAL(STEPS)
    DMU=MAXI-MINI
    DELTA=DMU/STEPSR
    F0=0.5*DELTA
    INTEGR=0.

DO IMU=1,STEPS
    MUI=MINI+F0+(IMU-1)*DELTA
    CALL INTEGRMUO(XX,MUI,MINO,MAXO,STEPS,FUNC,NUM,ARG_LENGTH)
    INTEGR=INTEGR+FUNC*DELTA
END DO

INTEGR=INTEGR/DMU

DEALLOCATE( DMU,DELTA,F0,MUI,FUNC )

END SUBROUTINE INTEGRMUI






! -------------------------------------------------------------------------
!
SUBROUTINE INTEGRMUO(XX,MUI,MINO,MAXO,STEPS,INTEGR,NUM,ARG_LENGTH)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINO TO MAXO IN STEPS INTERVALS OF THE FI
!       PHASE FUNCTION.
!
!
!   INTEGR = INTEGRMUO(XX,MUI,MINO,MAXO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      2.1    MD 21 NOV 05 MADE ALL LOCALS ALLOCATABLE
!
!   USES: INTEGRFI
!
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM,STEPS,ARG_LENGTH(2)
REAL,INTENT(IN) :: MUI(NUM),MINO(ARG_LENGTH(1)),MAXO(ARG_LENGTH(2)),XX(NUM)
REAL,INTENT(OUT) :: INTEGR(NUM)
REAL :: MINOS,MAXOS
REAL,DIMENSION(:), ALLOCATABLE ::  DMU,DELTA,F0,MUO,FUNC
INTEGER IMU,I

ALLOCATE( DMU(NUM),DELTA(NUM),F0(NUM),MUO(NUM),FUNC(NUM) )

IF (ARG_LENGTH(1)==1) THEN
    ! N.B. IF MINO IS SCALAR, MAXO IS VECTOR
    MINOS=MINO(1)
    DMU=MAXO-MINOS
ELSEIF (ARG_LENGTH(2)==1) THEN
    ! N.B. IF MAXO IS SCALAR, MINO IS VECTOR
    MAXOS=MAXO(1)
    DMU=MAXOS-MINO
ELSE
    DMU=MAXO-MINO
END IF

DELTA=DMU/STEPS
F0=0.5*DELTA
INTEGR=0.0

DO IMU=1,STEPS
    IF (ARG_LENGTH(1)==1) THEN
        MUO=MINOS+F0+(IMU-1)*DELTA
    ELSE
        MUO=MINO+F0+(IMU-1)*DELTA
    END IF
    CALL INTEGRFI(XX,MUI,MUO,STEPS,FUNC,NUM)
    INTEGR=INTEGR+FUNC*DELTA
END DO

INTEGR=INTEGR/2

DEALLOCATE( DMU,DELTA,F0,MUO,FUNC )

END SUBROUTINE INTEGRMUO





! -------------------------------------------------------------------------
!
SUBROUTINE INTEGRFI(XX,MUI,MUO,STEPS,INTEGR,NUM)
!
! -------------------------------------------------------------------------
!
!   CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES INTEGRATION  OVER INCIDENT DIRECTIONS, MUI
!       FROM MINI TO MAXI IN STEPS INTERVALS OF THE FI
!       PHASE FUNCTION.
!
!
!   INTEGR = INTEGRFI(XX,MUI,MUO,STEPS)
!
!   VERSION HISTORY:
!      1.0     WI 27.05.98
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      2.1    MD 21 NOV 05 CHANGED ALL LOCALS TO ALLOCATABLE
!
!   USES: - NONE
!
!   COPYRIGHT (C) 1998 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM,STEPS
REAL, INTENT(IN) :: XX(NUM),MUI(NUM),MUO(NUM)
REAL, INTENT(OUT) :: INTEGR(NUM)
REAL PI,DELTA,FI,F0,COFI,SI2FI

INTEGER :: IFI

REAL,DIMENSION(:),ALLOCATABLE ::  X2,SII,SIO,COSTE,SI2CHI,FUNC

ALLOCATE( X2(NUM),SII(NUM),SIO(NUM),COSTE(NUM),SI2CHI(NUM),FUNC(NUM) )

PI=3.14159
DELTA=PI/STEPS
F0=0.5*DELTA
INTEGR=0
X2=2*XX**2

DO IFI=1,STEPS
    FI=F0+(IFI-1)*DELTA
    SII=(1-MUI**2)**0.5
    SIO=(1-MUO**2)**0.5
    COFI=COS(FI)
    SI2FI=1-COFI**2
    COSTE=MUI*MUO+SII*SIO*COFI
    SI2CHI=0.5*(1+COSTE**2)
    FUNC=SI2CHI/(1+(1-COSTE)*X2)**2
    INTEGR=INTEGR+FUNC*DELTA
END DO

INTEGR=INTEGR/PI

DEALLOCATE( X2,SII,SIO,COSTE,SI2CHI,FUNC )

END SUBROUTINE INTEGRFI


