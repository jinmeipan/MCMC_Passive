! -------------------------------------------------------------------------
!
SUBROUTINE PFADI(TEI,DI,DEI,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE EFFECTIVE PATH LENGTH IN A LAYER
!
!   DEI = PFADI(TEI,DI)
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       TEI:  LOCAL INCIDENCE ANGLE
!       DI:   THICKNESS [M]
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: TEI(NUM+1),DI(NUM)
REAL, INTENT(OUT) :: DEI(NUM)

DEI=DI/COS(TEI(1:NUM))

END SUBROUTINE PFADI






! -------------------------------------------------------------------------
!
SUBROUTINE FRESNELC(TEI,EPSI,SIH,SIV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   FRESNEL REFLECTION COEFFICIENTS (ASSUMING EPS'' = 0)
!     (LAYER N+1 IS THE AIR ABOVE THE SNOWPACK)
!
!   [SIH,SIV] = FRESNEL(TEI,ROI)
!       SIH:  INTERFACE REFLECTIVITY AT H POL
!       SIV:  INTERFACE REFLECTIVITY AT V POL
!       TEI:  LOCAL INCIDENCE ANGLE
!       EPSI: REAL PART OF DIELECTRIC PERMITTIVITY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES:
!       EPSR
!
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: TEI(NUM+1),EPSI(NUM)
!ctvs REAL, INTENT(OUT) :: SIH(NUM-1),SIV(NUM-1)
REAL, INTENT(OUT) :: SIH(NUM),SIV(NUM)
INTEGER :: I
REAL EPSO,EPSU,TEIN
REAL,DIMENSION(:),ALLOCATABLE:: EPSI_LOCAL

ALLOCATE(EPSI_LOCAL(NUM+1))

EPSI_LOCAL(1:NUM)=EPSI
EPSI_LOCAL(NUM+1)=1

DO I=1,NUM
    EPSO=EPSI_LOCAL(I+1)
    EPSU=EPSI_LOCAL(I)
    TEIN=TEI(I+1)

    SIH(I)=((EPSO**0.5*COS(TEIN)-(EPSU-EPSO*SIN(TEIN)**2)**0.5)/&
    (EPSO**0.5*COS(TEIN)+(EPSU-EPSO*SIN(TEIN)**2)**0.5))**2

    SIV(I)=((EPSU*COS(TEIN)-EPSO**0.5*(EPSU-EPSO*SIN(TEIN)**2)**0.5)/&
    (EPSU*COS(TEIN)+EPSO**0.5*(EPSU-EPSO*SIN(TEIN)**2)**0.5))**2
END DO

DEALLOCATE(EPSI_LOCAL)

END SUBROUTINE FRESNELC






! -------------------------------------------------------------------------
!
SUBROUTINE SLRED(NUM,ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,WI,GAI,FREQ, &
RNUM,XROI,XEPSI,XEPSII,XTEI,XSIH,XSIV,XDI,XDEI,XTI,XPCI,XWI,XGAI)
!
! -------------------------------------------------------------------------
!
!   LOCATES AND TREATS COHERENT LAYERS IN A SNOWPACK
!     SEE TECHNOTE 11
!
!   [RNUM,RROI,REPSI,REPSII,RTEI,RSIH,RSIV,RDI,RDEI,RTI,RPCI,RWI,RGAI]=
!       SLRED(NUM,ROI,EPSI,EPSII,TEI,SIH,SIV,DI,DEI,TI,PCI,FREQ,WI,GAI)
!       NUM:  INDEX OF THE LAYER IN THE ORIGINAL SNOWPACK
!       ROI:  DENSITY [G/CM^3]
!       EPSI:
!       EPSII:
!       TEI:  LOCAL INCIDENCE ANGLE
!       SIH:  LAYER REFLECTIVITY AT H POL
!       SIV:  LAYER REFLECTIVITY AT V POL
!       DI:   LAYER THICKNESS
!       DEI:  LOCAL PATH LENGTH [M]
!       TI:   PHYSICAL SNOW TEMPERATURE [K]
!       PCI:  CORRELATION LENGTH [MM]
!       WI:   WETNESS
!       GAI:  ABSORPTION COEFFICIENT
!       FREQ: FREQUENCY
!
!      1.0    WI 21.8.95
!      2.0    WI 13.8.98  COMPLETELY REWRITTEN
!      3.0    MD 1  APR 05 STRIPPED DOWN TO ONLY CHECK FOR COHERENT LAYERS -MD
!      3.1    MD 18 APR 05 FUNCTIONALITY ADDED TO DEAL WITH COHERENT LAYERS,
!                            SO LONG AS THERE ARE NOT SUCCESSIVE LAYERS
!      3.2    MD 04 NOV 05 FUNCTIONALITY ADDED TO DEAL WITH SUCCESSIVE
!                            COHERENT LAYERS FOR THREE LAYERS
!      3.3    MD 12 NOV 05 CHANGED TO DYNAMICALLY ALLOCATE ALL LOCALS
!      4.0    JG 10 DEC 10 ADDED FUNCTIONALITY FROM MATLAB FOR ARBITRARY
!                            NUMBER OF LAYERS
!      4.1    MD 08 APR 11 SLIGHT TWEAKS TO JG'S CODE
!
!   USES:
!       FRESNELRC
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(INOUT) :: ROI(NUM),EPSI(NUM),EPSII(NUM),TEI(NUM+1),SIH(NUM),&
SIV(NUM),DI(NUM),DEI(NUM),TI(NUM),PCI(NUM),WI(NUM),GAI(NUM)
REAL,INTENT(IN) :: FREQ
REAL,INTENT(OUT) :: XROI(NUM),XEPSI(NUM),XEPSII(NUM),XTEI(NUM+1),XSIH(NUM),&
XSIV(NUM),XDI(NUM),XDEI(NUM),XTI(NUM),XPCI(NUM),XWI(NUM),XGAI(NUM)
INTEGER, INTENT(OUT) :: RNUM
INTEGER, DIMENSION(:), ALLOCATABLE :: I,A
REAL CC,PI,FIC,FC,THETA
REAL,DIMENSION(:),ALLOCATABLE ::  NS,FI,X
INTEGER J,NTHIN,PL,SC,SCMAX,ML,MLO,M,K,NAEQ0,NAEQ1,tnum
REAL FITOT
REAL,DIMENSION(:),ALLOCATABLE :: TROI,TEPSI,TEPSII,TTEI,FITV,&
TSIH,TSIV,TDI,TDEI,TTI,TPCI,TWI,TGAI,TNS,TFI,EPSI_AUG,FH,FV
REAL,DIMENSION(:),ALLOCATABLE :: T2ROI,T2EPSI,T2EPSII,T2TEI,&
T2DI,T2DEI,T2TI,T2PCI,T2WI,T2GAI,T2NS,T2FI
INTEGER TAL
LOGICAL,DIMENSION(:),ALLOCATABLE :: MASK

!integer,intent(in) :: pixel,replicate,rank,meas

ALLOCATE( NS(NUM),FI(NUM), X(NUM) )

! IN GENERAL, WE FIRST TEST TO SEE IF THERE ARE ANY COHERENT LAYERS.  IF NOT,
!   WE SKIP TO CASE 2, OTHERWISE, WE HAVE CASE 1.  IN CASE 1, THE FIRST STEP IS
!   TO TREAT THE EFFECT OF SUCCESSIVE COHERENT SNOWPACK LAYERS BY COMBINING
!   THESE INTO A SINGLE LAYER. IF THERE ARE NO SUCCESSIVE COHERENT LAYERS,
!   WE SKIP TO STEP 2; REGARDLESS, THE ARRAYS WITH THE T- PREFIX ARE DEFINED
!   BEFORE STEP 2.  IN STEP 2, THE EFFECT OF ISOLATED COHERENT LAYERS IS
!   DEALT WITH BY INCORPORATING THE EFFECT OF EACH COHERENT LAYER INTO THE
!   INTER-LAYER REFLECTIVITIES.

! CONSTANTS
CC=0.299793
PI=3.14159
FIC=4*PI*FREQ/CC
FC=4.712

! COMPUTE FI IN ORDER TO CHECK ON COHERENT LAYERS
THETA=TEI(NUM+1)
NS=EPSI**0.5
FI=FIC*DI*NS*COS(TEI(1:NUM))

! COUNT THE THIN LAYERS
NTHIN=0
DO J=1,NUM
    IF (FI(J)<FC) THEN
        NTHIN=NTHIN+1
    END IF
END DO

! ALLOCATE THE I ARRAY, WHICH CONTAINS THE INDECES OF THE THIN LAYERS
ALLOCATE(I(1:NTHIN),A(NUM))

! DEFINE THE I AND A ARRAYS.  THE A ARRAY HAS A VALUE OF 1 FOR THIN
!   LAYERS AND 0 OTHERWISE
K=0
DO J=1,NUM
    IF (FI(J)<FC) THEN
        K=K+1
        I(K)=J
        A(J)=1
    ELSE
        A(J)=0
    END IF
END DO
! THE BOTTOM LAYER IS ALWAYS ASSUMED NONCOHERENT
A(1)=0



! CHECK TO SEE IF WE HAVE ANY COHERENT LAYERS TO TREAT.  IF NOT, ALLOCATE
!   THE REPLACEMENT ARRAYS (WITH THE 'R' PREFIX) WITH A SIZE OF THE ORIGINAL
!   NUMBER OF LAYERS, THEN DEFINE THOSE ARRAYS BASED ON THE ORIGINAL VALUES
! IF THERE IS ONLY ONE LAYER, IT IS ASSUMED TO BE NONCOHERENT, SO THE ORIGINAL
!   NUMBER OF LAYERS IS ASSIGNED TO RNUM AND THE OUTPUTS SET TO THE INPUTS.

IF (NTHIN>0.AND.NUM.GT.1) THEN
! CASE 1: TREAT COHERENT LAYERS IN THE SNOWPACK
! 1) IDENTIFY SUCCESSIVE COHERENT LAYERS AND MARK THE PACKS FROM 2,3...SCMAX
    PL=0
    SC=1
    SCMAX=0
    ML=0
    MLO=0

    DO M=2,NUM
        IF (A(M)==1 .AND. PL==1) THEN
            IF(ML==0)THEN
                SC=SC+1
                ML=1
                A(M-1)=SC
            END IF

            A(M)=SC
            SCMAX=SC
        ELSE
            IF (PL==1) THEN
                PL=0
            ELSE
                IF(A(M)==1)THEN
                    PL=1
                    ML=0
                END IF
            END IF
        END IF
    END DO

    !JG'S CODE TO ALLOW SUCCESSIVE COHERENT LAYERS BEGINS HERE. MD, 4/8/2011
    IF (SCMAX>0) THEN
        ! COMBINE SUCCESSIVE COHERENT LAYERS BY WEIGHTING WITH THE PHASE
        ! COPY ARRAYS TO TEMPORARIES FOR SIMPLICITY OF CODE
        ALLOCATE(T2DI(NUM),T2DEI(NUM),T2ROI(NUM),T2TI(NUM),T2WI(NUM),T2PCI(NUM),&
        T2NS(NUM),T2GAI(NUM),T2EPSI(NUM),T2EPSII(NUM),T2TEI(NUM+1),T2FI(NUM))
        ALLOCATE(MASK(NUM),FITV(NUM))
        T2DI=DI
        T2DEI=DEI
        T2ROI=ROI
        T2TI=TI
        T2WI=WI
        T2PCI=PCI
        T2NS=NS
        T2GAI=GAI
        T2EPSI=EPSI
        T2EPSII=EPSII
        T2TEI=TEI
        T2FI=FI
        ! COMBINE LAYERS
        DO M=2,SCMAX
            MASK=(A==M)
            FITOT=SUM(FI,1,MASK)
            FITV=FI/FITOT        ! WILL USE ONLY ELEMENTS CORRESPONDING TO MASK
            ! FIND MAXIMUM INDEX FOR WHICH A==M
            TAL=NUM
            DO WHILE (.NOT. MASK(TAL))
                TAL=TAL-1
            END DO
            ! THIS IS NOT EFFICIENT, JUST A QUICK AND SIMPLE TRANSLATION FROM MATLAB
            T2DI(TAL)=SUM(DI,1,MASK)
            T2DEI(TAL)=SUM(DEI,1,MASK)
            T2ROI(TAL)=SUM(ROI*FITV,1,MASK)
            T2TI(TAL)=SUM(TI*FITV,1,MASK)
            T2WI(TAL)=SUM(WI*FITV,1,MASK)
            T2PCI(TAL)=SUM(PCI*FITV,1,MASK)
            T2NS(TAL)=SUM(NS*FITV,1,MASK)
            T2GAI(TAL)=SUM(GAI*FITV,1,MASK)
            T2EPSI(TAL)=SUM(EPSI*FITV,1,MASK)
            T2EPSII(TAL)=SUM(EPSII*FITV,1,MASK)
            T2TEI(TAL)=SUM(TEI(1:NUM)*FITV,1,MASK)
            T2FI(TAL)=FITOT
            A(TAL)=1
        ENDDO

        ! REMOVE REDUNDANT LAYERS THAT WERE COMBINED WITH SUCCESIVE LAYERS
        ! SAVE NEW ARRAYS IN Tx ARRAYS
        MASK=(A<2)
        TNUM=COUNT(MASK)
        !    ALLOCATE(TDI(TNUM),TDEI(TNUM),TROI(TNUM),TTI(TNUM),TWI(TNUM),TPCI(TNUM),TNS(TNUM),& !Mike removing the duplicate TNS() allocation
        ALLOCATE(TDI(TNUM),TDEI(TNUM),TROI(TNUM),TTI(TNUM),TWI(TNUM),TPCI(TNUM),&
        TNS(TNUM),TGAI(TNUM),TEPSI(TNUM),TEPSII(TNUM),TTEI(TNUM+1),TFI(TNUM))
        TDI=PACK(T2DI,MASK)
        TDEI=PACK(T2DEI,MASK)
        TROI=PACK(T2ROI,MASK)
        TTI=PACK(T2TI,MASK)
        TWI=PACK(T2WI,MASK)
        TPCI=PACK(T2PCI,MASK)
        TNS=PACK(T2NS,MASK)
        TGAI=PACK(T2GAI,MASK)
        TEPSI=PACK(T2EPSI,MASK)
        TEPSII=PACK(T2EPSII,MASK)
        TTEI(1:TNUM)=PACK(T2TEI(1:NUM),MASK)
        !    TTEI(TNUM+1)=NUM+1     !JG'S LINE
        TTEI(TNUM+1)=TEI(NUM+1) !MD's EDIT, 4/8/11
        TFI=PACK(T2FI,MASK)
        DEALLOCATE(T2DI,T2DEI,T2ROI,T2TI,T2WI,T2PCI,T2NS,T2GAI,T2EPSI,T2EPSII,&
            T2TEI,T2FI)
        DEALLOCATE(MASK,FITV)
    ELSE
        !IF THERE ARE NO SUCCESSIVE COHERENT LAYERS, I WILL MAP THE x ARRAYS TO
        !  THE Tx ARRAYS...
        ALLOCATE(TDI(NUM),TDEI(NUM),TROI(NUM),TTI(NUM),TWI(NUM),TPCI(NUM),&
        TNS(NUM),TGAI(NUM),TEPSI(NUM),TEPSII(NUM),TTEI(NUM+1),TFI(NUM))
        TDI=DI
        TDEI=DEI
        TROI=ROI
        TTI=TI
        TWI=WI
        TPCI=PCI
        TNS=NS
        TGAI=GAI
        TEPSI=EPSI
        TEPSII=EPSII
        TTEI=TEI
        TFI=FI
        TNUM=NUM
    ENDIF
    DEALLOCATE(I,A) ! THIS WAS ADDED BY MD, 4/8/11. JG HAD REMOVED IT.
    ! IT NEEDS TO BE IN SINCE A,I ARE REALLOCATED BELOW.

    ! 2) DEAL WITH ISOLATED COHERENT LAYERS BY COMBINING THESE LAYERS' EFFECTS
    ! INTO THE INTER-LAYER REFLECTIVITIES

    ! COUNT THE THIN LAYERS AFTER REMOVAL OF SUCCESSIVE COHERENT LAYERS.

    ! NOTE THAT THE BOTTOM LAYER IS ALWAYS ASSUMED NON-COHERENT: DON'T COUNT IT.
    ! THIS CHANGE MADE BY MD, 4/8/11
    NTHIN=0
    DO J=2,TNUM
        IF (TFI(J)<FC ) THEN
            NTHIN=NTHIN+1
        END IF
    END DO

    ! ALLOCATE THE A ARRAY WHICH MARKS COHERENT LAYERS; THE I ARRAY SWITCHES
    !   BETWEEN MARKING INDECES OF COHERENT AND NONCOHERENT LAYERS.  THE GOAL
    !   IS TO CALCULATE THE INTERFACE REFLECTIVITIES.

    !  ALLOCATE(I(NTHIN),A(TNUM)) !THIS CHANGE BY MD, 4/8/11: I SHOULD BE SAME
    !    SIZE AS A. IT IS NOT USED, ANYWAY, HERE, AND IS DEALLOCATED, SO SHOULD
    !    PROBABLY JUST REMOVE IN THE FUTURE.
    ALLOCATE(I(TNUM),A(TNUM))

    ! REDEFINE THE I AND A ARRAYS.  THE A ARRAY HAS A VALUE OF 1 FOR THIN
    !   LAYERS AND 0 OTHERWISE, NOW THAT THERE ARE NO SUCCESSIVE COHERENT LAYERS
    K=0
    DO J=1,TNUM
        IF (TFI(J)<FC) THEN
            K=K+1
            I(K)=J
            A(J)=1
        ELSE
            A(J)=0
        END IF
    END DO
    ! THE BOTTOM LAYER IS ALWAYS ASSUMED NONCOHERENT
    A(1)=0
    DEALLOCATE(I) !I IS NOT USED NOW

    !  FIND THE VALUES OF A EQUAL TO ZERO, SAVE THE INDECES TO I
    NAEQ0=0
    DO J=1,TNUM
        IF (A(J)==0) THEN
            NAEQ0=NAEQ0+1
        END IF
    END DO
    ALLOCATE(I(NAEQ0))

    K=0
    DO J=1,TNUM
        IF (A(J)==0) THEN
            K=K+1
            I(K)=J
        END IF
    END DO

    ! CALCULATE INTERFACE REFLECTION COEFFICIENTS
    ALLOCATE(EPSI_AUG(TNUM+1),FH(TNUM),FV(TNUM))
    EPSI_AUG(1:TNUM)=TEPSI
    EPSI_AUG(TNUM+1)=1.0

    CALL FRESNELRC(TTEI,EPSI_AUG,FH,FV,TNUM)

    ! FOR LAYERS OF TYPE 0 SHI = FH^2
    ALLOCATE(TSIH(TNUM),TSIV(TNUM))
    DO J=1,NAEQ0
        TSIH(I(J))=FH(I(J))**2
        TSIV(I(J))=FV(I(J))**2
    END DO

    IF(NTHIN.EQ.0)THEN
        ! THERE ARE NO MORE COHERENT LAYERS AFTER REMOVAL OF SUCCESSIVE COHERENT
        ! LAYERS SO SET THE OUTPUT ARRAYS EQUAL TO CURRENT Tx ARRAYS
        RNUM=TNUM
        XROI(1:RNUM)=TROI
        XEPSI(1:RNUM)=TEPSI
        XEPSII(1:RNUM)=TEPSII
        XTEI(1:RNUM+1)=TTEI
        XSIH(1:RNUM)=TSIH
        XSIV(1:RNUM)=TSIV
        XDI(1:RNUM)=TDI
        XDEI(1:RNUM)=TDEI
        XTI(1:RNUM)=TTI
        XPCI(1:RNUM)=TPCI
        XWI(1:RNUM)=TWI
        XGAI(1:RNUM)=TGAI
    ELSE
    ! IF THERE ARE STILL COHERENT LAYERS AFTER REMOVAL OF SUCCESSIVE COHERENT
    ! LAYERS, THEN DEAL WITH THESE.  DO A REDUCTION ON LAYERS OF TYPE 0
    !   (COHERENT LAYER EFFECTS ARE TAKEN INTO ACCOUNT IN THE LAYER
    !   REFLECTIVITIES)

    !  FIND THE NUMBER OF VALUES OF A EQUAL TO ONE

        DEALLOCATE(I)
        NAEQ1=0
        DO J=1,TNUM
            IF (A(J)==1) THEN
                NAEQ1=NAEQ1+1
            END IF
        END DO
        ALLOCATE(I(1:NAEQ1))

        !  FIND THE VALUES OF A EQUAL TO ONE
        K=0
        DO J=1,TNUM
            IF (A(J)==1) THEN
                K=K+1
                I(K)=J
            END IF
        END DO

        !COMPUTE NEW INTERFACE REFLECTIVITIES
        X=0 !INITIALIZE VARIABLES
        !    XSIH=TSIH
        !    XSIV=TSIV
        DO J=1,NAEQ1
            X(I(J))=2*FH(I(J))*FH(I(J)-1)*COS(FI(I(J)))
            TSIH(I(J)-1)=(FH(I(J))**2+FH(I(J)-1)**2+X(I(J)))/&
            (1+FH(I(J))**2*FH(I(J)-1)**2+X(I(J)))
            X(I(J))=2*FV(I(J))*FV(I(J)-1)*COS(FI(I(J)))
            TSIV(I(J)-1)=(FV(I(J))**2+FV(I(J)-1)**2+X(I(J)))/&
            (1+FV(I(J))**2*FV(I(J)-1)**2+X(I(J)))
        END DO

        !  FIND THE NUMBER OF VALUES OF A EQUAL TO ZERO
        DEALLOCATE(I)
        NAEQ0=0
        DO J=1,TNUM
            IF (A(J)==0) THEN
                NAEQ0=NAEQ0+1
            END IF
        END DO
        ALLOCATE(I(NAEQ0))

        !  FIND THE VALUES OF A EQUAL TO ZERO
        K=0
        DO J=1,TNUM
            IF (A(J)==0) THEN
                K=K+1
                I(K)=J
            END IF
        END DO

        !  DEFINE OUTPUT VARIABLES BASED ON I ARRAY
        DO J=1,NAEQ0
        !      XROI(J)=ROI(I(J))
        !      XTEI(J)=TEI(I(J))
        !      XDI(J)=DI(I(J))
        !      XTI(J)=TI(I(J))
        !      XPCI(J)=PCI(I(J))
        !      XWI(J)=WI(I(J))
        !      XGAI(J)=GAI(I(J))
            XROI(J)=TROI(I(J))
            XTEI(J)=TTEI(I(J))
            XDI(J)=TDI(I(J))
            XTI(J)=TTI(I(J))
            XPCI(J)=TPCI(I(J))
            XWI(J)=TWI(I(J))
            XGAI(J)=TGAI(I(J))

        !      XSIH(J)=XSIH(I(J))
        !      XSIV(J)=XSIV(I(J))

            XSIH(J)=TSIH(I(J))
            XSIV(J)=TSIV(I(J))

        !      XEPSI(J)=EPSI(I(J))
        !      XEPSII(J)=EPSII(I(J))
        !      XDEI(J)=DEI(I(J))
            XEPSI(J)=TEPSI(I(J))
            XEPSII(J)=TEPSII(I(J))
            XDEI(J)=TDEI(I(J))
        END DO

        RNUM=TNUM-NTHIN
        XTEI(RNUM+1)=THETA
    END IF

    DEALLOCATE(TDI,TDEI,TROI,TTI,TWI,TPCI,TNS,TGAI,TEPSI,TEPSII,TTEI,TFI,&
    TSIH,TSIV)
    DEALLOCATE(EPSI_AUG,FH,FV) !Jinmei added Dec23,2015


ELSE
    ! THERE ARE NO COHERENT LAYERS (OR ONLY ONE LAYER), SO SET THE OUTPUT
    ! ARRAYS EQUAL TO THE INPUT ARRAYS
    RNUM=NUM
    XROI=ROI
    XEPSI=EPSI
    XEPSII=EPSII
    XTEI=TEI
    XSIH=SIH
    XSIV=SIV
    XDI=DI
    XDEI=DEI
    XTI=TI
    XPCI=PCI
    XWI=WI
    XGAI=GAI
END IF


DEALLOCATE( NS,FI, X )
DEALLOCATE(I,A)  !Jinmei added Dec23,2015

END SUBROUTINE SLRED






! -------------------------------------------------------------------------
!
SUBROUTINE AOT(EPS_T,EPS_B,TETAD_SOIL)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM PULLIAINEN
!
!     FUNCTION FOR CALCULATING THE ANGLE OF TRANSMISSION
!     IN THE CASE OF A PLANE BOUNDARY BETWEEN TWO
!     MEDIAS WITH COMPLEX PERMITTIVITIES
!     K. TIGERSTEDT/97
!
!   INPUT PARAMETERS:
!     EPS_T = TOP LAYER EPSILON_R [COMPLEX],
!     EPS_B = BOTTOM LAYER EPSILON_R [COMPLEX]
!     THETAD = INCIDENCE ANGLE [DEG]
!   OUTPUT:
!     KSID   = TRANSMISSION ANGLE IN BOTTOM LAYER [DEG]
!
!   VERSION HISTORY:
!      1.0    KT ?.?.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB

IMPLICIT NONE

REAL, INTENT(IN) :: EPS_T,EPS_B
REAL, INTENT(INOUT) :: TETAD_SOIL
REAL THETA,KSI,PI
COMPLEX NUMERATOR,DENOMINATOR

PI=3.14159
THETA=TETAD_SOIL/180*PI
NUMERATOR=EPS_T**0.5*SIN(THETA)
DENOMINATOR=(EPS_B-EPS_T*(1-COS(THETA)**2))**0.5

KSI=ATAN(REAL(NUMERATOR)/REAL(DENOMINATOR))
TETAD_SOIL=KSI/PI*180

END SUBROUTINE AOT







! -------------------------------------------------------------------------
!
SUBROUTINE PFADC(TETA,DI,EPSI,GS6,DEI,TEI,TSCAT,NUM)
!
! -------------------------------------------------------------------------
!
!      CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE EFFECTIVE PATH LENGTH IN A LAYER
!
!   [DEI,TEI,TSCAT] = PFADC(TETA,DI,EPSI,GS6)
!       DEI:  EFFECTIVE PATH LENGTH [M]
!       TEI:  LOCAL INCIDENCE ANGLE
!       TSCAT: SCATTERING
!       TETA: INCIDENCE ANGLE AT SNOW AIR INTERFACE
!       DI:   THICKNESS [M]
!       EPSI: DIELECTRIC PERMITTIVITY
!       GS6:  6-FLUX SCATTERING COEFFICIENT
!
!   VERSION HISTORY:
!      1.0    WI 15.10.97
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!      2.1    MD 21 NOV 05 CHANGED ALL LOCALS TO ALLOCATBLE
!
!
!   USES: - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER, INTENT(IN) :: NUM
REAL, INTENT(IN) :: TETA,DI(NUM),EPSI(NUM),GS6(NUM)
REAL, INTENT(OUT) :: DEI(NUM),TEI(NUM),TSCAT(NUM)
REAL,DIMENSION(:),ALLOCATABLE ::  NS,COSTETASN,COSC,COSTETASC,TAUSCAT,COSTETA
INTEGER I

ALLOCATE( NS(NUM),COSTETASN(NUM),COSC(NUM),COSTETASC(NUM),TAUSCAT(NUM+1),&
COSTETA(NUM) )

NS=EPSI**0.5
COSTETASN=(1-(SIN(TETA)/NS)**2)**0.5
COSC=(1-(1/NS)**2)**0.5
COSTETASC=0.5*(1+COSC)
DEI=DI/COSTETASN

TAUSCAT(NUM+1)=0

DO I=NUM,1,-1
TAUSCAT(I)=TAUSCAT(I+1)+DEI(I)*GS6(I)/2
TSCAT(I)=EXP(-1*TAUSCAT(I))
COSTETA(I)=TSCAT(I)*COSTETASN(I)+(1-TSCAT(I))*COSTETASC(I)
END DO

TEI=ACOS(COSTETA)

DEALLOCATE (  NS,COSTETASN,COSC,COSTETASC,TAUSCAT,COSTETA )

END SUBROUTINE PFADC







! -------------------------------------------------------------------------
!
SUBROUTINE POLMIX(TSCAT,SIH,SIV,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE POLARIZATION MIXING OF THE INTERFACE REFLECTIVITIES
!       OF EACH LAYER (TAKING INTO ACCOUNT THE FIRST ORDER SCATTERING)
!
!   [SIH,SIV] = POLMIX(TSCAT,SIH,SIV)
!       SIH:   INTERFACE REFLECTIVITY AT H-POL
!       SIV:   INTERFACE REFLECTIVITY AT V-POL
!       TSCAT: TAU SCAT
!
!   VERSION HISTORY:
!      1.0    WI 14.10.97
!      1.1    WI  4.11.97  BUG FIX (LAYER NUMBERING PROBLEM)
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES - NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: TSCAT(NUM)
REAL,INTENT(INOUT) :: SIH(NUM+1),SIV(NUM+1)
REAL,DIMENSION(:),ALLOCATABLE ::  TSCATLONG,SMEAN,DELTAS

ALLOCATE( TSCATLONG(NUM+1),SMEAN(NUM+1),DELTAS(NUM+1) )

TSCATLONG(1:NUM)=TSCAT(1:NUM)
TSCATLONG(NUM+1)=1.

SMEAN=0.5*(SIH+SIV)
DELTAS=0.5*TSCATLONG*(SIH-SIV)

SIH=SMEAN+DELTAS
SIV=SMEAN-DELTAS

DEALLOCATE( TSCATLONG,SMEAN,DELTAS )

END SUBROUTINE POLMIX







! -------------------------------------------------------------------------
!
SUBROUTINE RT(GAI,GBI,DEI,RI,TI,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE LAYER REFLECTIVITY AND TRANSMISSIVITY
!
!
!   [RI,TI] = RT(GAI,GBI,DEI)
!       RI:   LAYER REFLECTIVITY
!       TI:   LAYER TRANSMISSIVITY
!       GAI:  ABSORPTION COEFFICIENT
!       GBI:  SCATTERING COEFFICIENT
!       DEI:  PATH LENGTH
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: NONE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: GAI(NUM),GBI(NUM),DEI(NUM)
REAL,INTENT(OUT) :: RI(NUM),TI(NUM)
REAL,DIMENSION(:),ALLOCATABLE :: MYGAMMA,T0I,R0I,T02,R02
INTEGER I

ALLOCATE( MYGAMMA(NUM),T0I(NUM),R0I(NUM),T02(NUM),R02(NUM) )

MYGAMMA=(GAI*(GAI+2*GBI))**0.5
T0I=EXP(-1*MYGAMMA*DEI)

DO I=1,NUM
IF(GBI(I)>0.00001)THEN
R0I(I)=GBI(I)/(GAI(I)+GBI(I)+MYGAMMA(I))
ELSE
R0I(I)=0
END IF
END DO

T02=T0I**2
R02=R0I**2
RI=R0I*(1-T02)/(1-T02*R02)
TI=T0I*(1-R02)/(1-T02*R02)

DEALLOCATE( MYGAMMA,T0I,R0I,T02,R02 )

END SUBROUTINE RT






! -------------------------------------------------------------------------
!
SUBROUTINE LAYER(RI,SI,TRI,TI,TGND,TSKY,D,NUM)
!
! -------------------------------------------------------------------------
!
!     CODE ORIGINALLY OBTAINED IN MATLAB FROM MATZLER
!
!   CALCULATES THE UPWELLING BRIGHTNESS TEMPERATURES D (SEE NOTE 6)
!
!   D = LAYER(RI,SI,TI,TI,TGND,TSKY)
!       D:    UPWELLING BRIGHTNESS TEMPERATURE
!       RI:   LAYER REFLECTIVITY
!       SI:   INTERFACE REFLECTIVITY
!       TI:   LAYER TRANSMISSIVITY
!       TI:   PHYSICAL TEMPERATURE [K]
!       TGND: BRIGHTNESS TEMPERATURE OF THE SOIL BELOW THE SNOWPACK
!       TSKY: BRIGHTNESS TEMPERATURE OF THE SKY
!
!   VERSION HISTORY:
!      1.0    WI 15.7.95
!      1.1    WI 26.9.97  HANDLES ALSO THE SPECIAL CASE OF A SINGLE LAYER NOW
!      1.2    WI 02.03.99 FIXED ERROR IN 1 LAYER HANDLING
!      2.0    MD 1 APR 05 TRANSLATED TO FORTRAN FROM MATLAB
!
!   USES: - INVERT_MATRIX SUBROUTINE BY MIKE,ZEROSI INTERNAL FUNCTION AND
!              EYEI INTERNAL FUNCTION BY MIKE
!
!   COPYRIGHT (C) 1997 BY THE INSTITUTE OF APPLIED PHYSICS,
!   UNIVERSITY OF BERN, SWITZERLAND

IMPLICIT NONE

INTEGER,INTENT(IN) :: NUM
REAL,INTENT(IN) :: RI(NUM),SI(NUM+1),TRI(NUM),TI(NUM),TGND,TSKY
REAL,INTENT(OUT) :: D(NUM)
REAL K1
REAL,DIMENSION(:),ALLOCATABLE ::  EI,F,E
REAL,DIMENSION(:,:),ALLOCATABLE :: M1,H,EYE,M2,M3,M4,M5,INVIM1,INVIM5,EYEM1,&
EYEM5
INTEGER ROW,COL,I

!integer,intent(in) :: pixel

!PRINT *, ' '
!PRINT *, 'RI',RI,'SI',SI,'TRI',TRI,'TI',TI,'TGND',TGND,'TSKY',TSKY,'NUM',NUM


ALLOCATE( EI(NUM),M1(NUM,NUM),H(NUM-1,NUM-1),EYE(NUM,NUM),M2(NUM,NUM),&
M3(NUM,NUM),M4(NUM,NUM),E(NUM),F(NUM),M5(NUM,NUM),&
INVIM1(NUM,NUM),INVIM5(NUM,NUM),EYEM1(NUM,NUM),EYEM5(NUM,NUM) )

EI=1-RI-TRI

IF (NUM==1) THEN
!FOR ONE LAYER CASE, THIS IS THE ENTIRE CALCULATION; THE MATRIX INVERSION
! ROUTINE IS NOT NEEDED.  THEREFORE, A RETURN STATEMENT IS USED HERE...
K1=(1-RI(1)*SI(1))*(1-RI(1)*SI(2))-TRI(1)*SI(1)*TRI(1)*SI(2)
D=TRI(1)*SI(1)*((1-SI(1))*RI(1)*TGND+(1-SI(2))*TSKY*TRI(1)+&
EI(1)*TI(1))/K1 + (1-RI(1)*SI(1))*((1-SI(1))*TGND*TRI(1)+&
(1-SI(2))*TSKY*RI(1)+EI(1)*TI(1))/K1

!PRINT *, 'THIS IS D', D
!PRINT *, 'TSKY', TSKY
!PRINT *,TRI(1)*SI(1)*((1-SI(1))*RI(1)*TGND+(1-SI(2))*TSKY*TRI(1)+EI(1)*TI(1))/K1
!PRINT *, (1-RI(1)*SI(1))*((1-SI(1))*TGND*TRI(1)+(1-SI(2))*TSKY*RI(1)+EI(1)*TI(1))/K1
!PRINT *,'RI(1)',RI(1),'SI(1)',SI(1),'TGND',TGND,'TRI(1)',TRI(1),'SI(2)',SI(2),'EI(1)',EI(1)
!PRINT *,'TI(1)',TI(1),'K1',K1
!PRINT *,(1-RI(1)*SI(1)),(1-SI(1))*TGND*TRI(1),(1-SI(2))*TSKY*RI(1),EI(1)*TI(1)
!PRINT *,(1-SI(1))*TGND*TRI(1),(1-SI(1)),TGND,TRI(1)

RETURN
ELSE
! INITIALIZE ARRAYS
M1=ZEROSI(NUM,NUM)
H=ZEROSI(NUM-1,NUM-1)
M2=ZEROSI(NUM,NUM)
M3=ZEROSI(NUM,NUM)
M4=ZEROSI(NUM,NUM)

DO I=1,NUM
M1(I,I)=RI(I)*SI(I)
END DO
DO I=1,NUM-1
H(I,I)=TRI(I)*(1-SI(I+1))
END DO
M1(1:NUM-1:1,2:NUM:1)=M1(1:NUM-1:1,2:NUM:1)+H

EYE=EYEI(NUM)
H=ZEROSI(NUM-1,NUM-1)
DO I=1,NUM
M2(I,I)=TRI(I)*SI(I+1)
END DO
DO I=2,NUM
H(I-1,I-1)=RI(I)*(1-SI(I))
END DO
M2(2:NUM:1,1:NUM-1:1)=M2(2:NUM:1,1:NUM-1:1)+H

H=ZEROSI(NUM-1,NUM-1)
DO I=1,NUM
M3(I,I)=TRI(I)*SI(I)
END DO
DO I=1,NUM-1
H(I,I)=RI(I)*(1-SI(I+1))
END DO
M3(1:NUM-1:1,2:NUM:1)=M3(1:NUM-1:1,2:NUM:1)+H

H=ZEROSI(NUM-1,NUM-1)
DO I=1,NUM
M4(I,I)=RI(I)*SI(I+1)
END DO
DO I=2,NUM
H(I-1,I-1)=TRI(I)*(1-SI(I))
END DO
M4(2:NUM:1,1:NUM-1:1)=M4(2:NUM:1,1:NUM-1:1)+H

E=EI*TI
E(1)=E(1)+RI(1)*(1-SI(1))*TGND
E(NUM)=E(NUM)+TRI(NUM)*(1-SI(NUM+1))*TSKY

F=EI*TI
F(1)=F(1)+TRI(1)*(1-SI(1))*TGND
F(NUM)=F(NUM)+RI(NUM)*(1-SI(NUM+1))*TSKY

END IF

EYEM1=EYE-M1
CALL INVERT_MATRIX(EYEM1,INVIM1,NUM)

M5=MATMUL(M3,MATMUL(INVIM1,M2))+M4
EYEM5=EYE-M5
CALL INVERT_MATRIX(EYEM5,INVIM5,NUM)

D=MATMUL(INVIM5,(MATMUL(MATMUL(M3,INVIM1),E)+F))

!PRINT *, 'THIS IS D',D



DEALLOCATE( EI,M1,H,EYE,M2,M3,M4,E,F,M5,INVIM1,INVIM5,EYEM1,EYEM5 )

CONTAINS

FUNCTION ZEROSI(ROW,COL)

! BY MIKE, 1 APRIL 2005
!
! THIS FUNCTION IS INTERNAL TO LAYER SUBROUTINE
! MANY VALUES IN THE ABOVE ARRAYS ARE NEVER A VALUE OTHER THAN ZERO, SO INSTEAD
! OF USING WHATEVER VALUES ARE RANDOMLY ALLOCATED TO THE ARRAYS WHEN THEY ARE
! ALLOCATED, I SPECIFICALLY SET EACH POSITION TO ZERO.  THIS FUNCTION SHOULD
! BE ENTIRELY unneceSSARY, SINCE THE DEFAULT VALUES IN THE ARRAY SHOULD BE ZERO. NONETHELESS, I DECIDED TO EXPLICITLY ZERO OUT 2-D ARRAYS BEFORE USING THEM

IMPLICIT NONE

INTEGER,INTENT(IN):: ROW,COL
REAL :: ZEROSI(ROW,COL)
INTEGER I,J

DO I=1,ROW
DO J=1,COL
ZEROSI(I,J)=0.
END DO
END DO

END FUNCTION ZEROSI

FUNCTION EYEI(NUM)


! BY MIKE, 1 APRIL 2005
!
! THIS FUNCTION IS INTERNAL TO LAYER SUBROUTINE
! THIS FUNCTION DEFINES AN IDENTITY MATRIX OF SIZE NUM

INTEGER, INTENT(IN) :: NUM
REAL :: EYEI(NUM,NUM)
INTEGER I,J
DO I=1,NUM
DO J=1,NUM
IF (I==J) THEN
EYEI(I,J)=1
ELSE
EYEI(I,J)=0
END IF
END DO
END DO
END FUNCTION EYEI


END SUBROUTINE LAYER

